# .github/workflows/deploy.yml
name: Build, Embed Defender, and Deploy to ECR

on:
  push:
    branches:
      - main

# 환경 변수 설정
env:
  # terraform/variables.tf 와 일관성 유지
  AWS_REGION: "ap-northeast-2" 
  # terraform/ecs.tf 에 정의된 리포지토리 이름 형식과 일치시킴
  ECR_REPOSITORY: "hkjung-tetris-web-repo" 
  IMAGE_BASE_NAME: "tetris-web"

jobs:
  build-and-push:
    name: Build, Embed, and Push
    runs-on: ubuntu-latest
    
    # GitHub OIDC를 사용하여 AWS에 인증
    permissions:
      id-token: write 
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials from GitHub OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # IAM OIDC 설정 후 생성된 Role ARN을 GitHub Secret으로 등록하여 사용하세요.
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_FOR_GITHUB_ACTIONS }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # Step 1: GitHub Actions 환경 설정 (twistcli 다운로드)
      - name: Download and prepare twistcli
        env:
          PRISMA_CONSOLE_URL: ${{ secrets.PRISMA_CONSOLE_URL }}
          PRISMA_ACCESS_KEY: ${{ secrets.PRISMA_ACCESS_KEY }}
          PRISMA_SECRET_KEY: ${{ secrets.PRISMA_SECRET_KEY }}
        run: |
          # 1. URL 정리
          CLEAN_URL=$(echo "$PRISMA_CONSOLE_URL" | sed 's:/*$::')
          
          # 2. [수정 포인트] SaaS 인증은 보통 테넌트 ID가 포함된 경로가 아닌 
          # 베이스 도메인의 /api/v1/authenticate 를 사용해야 할 수도 있습니다.
          # 하지만 사용자가 준 공식 curl의 도메인을 따라 시도해봅니다.
          
          echo "Trying authentication..."
          # 만약 CLEAN_URL에 테넌트 ID가 포함되어 있다면, 베이스 도메인만 추출해봅니다.
          BASE_DOMAIN=$(echo "$CLEAN_URL" | cut -d'/' -f1-3)
          
          # 우선 CLEAN_URL 기반으로 시도하고, 안되면 BASE_DOMAIN으로 시도하는 로직
          AUTH_TOKEN=$(curl -k -s -u "$PRISMA_ACCESS_KEY:$PRISMA_SECRET_KEY" \
                       "$CLEAN_URL/api/v1/authenticate" | jq -r .token)
          
          if [ "$AUTH_TOKEN" == "null" ] || [ -z "$AUTH_TOKEN" ]; then
            echo "Failed with Tenant URL, trying Base Domain URL..."
            AUTH_TOKEN=$(curl -k -s -u "$PRISMA_ACCESS_KEY:$PRISMA_SECRET_KEY" \
                         "$BASE_DOMAIN/api/v1/authenticate" | jq -r .token)
          fi

          if [ "$AUTH_TOKEN" == "null" ] || [ -z "$AUTH_TOKEN" ]; then
            echo "Error: Still failed to get token. Printing response for debug:"
            curl -k -i -u "$PRISMA_ACCESS_KEY:$PRISMA_SECRET_KEY" "$CLEAN_URL/api/v1/authenticate"
            exit 1
          fi

          echo "Successfully obtained auth token."
          curl -k -L -H "Authorization: Bearer $AUTH_TOKEN" \
               "$CLEAN_URL/api/v1/util/twistcli?os=linux" --output twistcli
          
          chmod +x twistcli
          ./twistcli --version

      # Step 2: 이미지 빌드 및 Defender 주입 (The "Embed" Step)
      - name: Build base Docker image
        run: |
          docker build -t ${{ env.IMAGE_BASE_NAME }}:latest .

      - name: Embed Defender into the image using twistcli
        env:
          PRISMA_CONSOLE_URL: ${{ secrets.PRISMA_CONSOLE_URL }}
          PRISMA_ACCESS_KEY: ${{ secrets.PRISMA_ACCESS_KEY }}
          PRISMA_SECRET_KEY: ${{ secrets.PRISMA_SECRET_KEY }}
        run: |
          echo "Embedding Fargate Defender..."
          ./twistcli app-embedded embed \
            --app-id ${{ env.ECR_REPOSITORY }} \
            --data-folder /tmp \
            --image-name ${{ env.IMAGE_BASE_NAME }}:latest \
            --output-image ${{ env.IMAGE_BASE_NAME }}:protected \
            --address $PRISMA_CONSOLE_URL \
            --user $PRISMA_ACCESS_KEY \
            --password $PRISMA_SECRET_KEY
          echo "Embedding complete. New image is ${{ env.IMAGE_BASE_NAME }}:protected"

      # Step 3: ECR 푸시 (Push Protected Image)
      - name: Tag and push protected image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          COMMIT_HASH=$(git rev-parse --short HEAD)
          # 이미지 태그 전략: 'protected-{commit-sha}' 및 'latest-protected'
          docker tag ${{ env.IMAGE_BASE_NAME }}:protected $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:protected-$COMMIT_HASH
          docker tag ${{ env.IMAGE_BASE_NAME }}:protected $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest-protected
          
          echo "Pushing image $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:protected-$COMMIT_HASH"
          docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:protected-$COMMIT_HASH
          
          echo "Pushing image $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest-protected"
          docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest-protected